generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                    String          @id @default(cuid())
  name                  String
  email                 String          @unique
  phoneNumber           String?         @unique @map("phonenumber")
  password              String
  refreshToken          String?
  emailVerified         Boolean         @default(false)
  phoneVerified         Boolean         @default(false)
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  activationCode        String?
  verifiedAt            DateTime?
  resetCode             String?
  isDeleted             Boolean         @default(false)
  deletedAt             DateTime?
  deletionScheduledFor  DateTime?
  role                  String          @default("USER")
  googleId              String?         @unique
  googleEmail           String?
  accountBlocked        Boolean         @default(false)
  blockedAt             DateTime?
  blockedReason         String?
  Team                  Team[]
  User                  TeamMember[]
  Subscription          Subscription?
  BillingInfo           BillingInfo?
  Feedback              Feedback[]
}

model Team {
  id        String   @id @default(cuid())
  name      String?
  ownerId   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  members   TeamMember[]
  Content       Content[]
  CustomerBots  CustomerBots[]
  CustomerChats CustomerChats[]
  Quota         Quota[]
  Storage       Storage[]
}

model TeamMember {
  id              String   @id @default(cuid())
  teamId          String
  userId          String?
  email           String?
  role            String   @default("TEAM_MEMBER")
  status          String   @default("pending")
  invitationToken String?  @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  team            Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([teamId, userId])
  @@unique([teamId, email])
}

model Quota {
  id        String     @id @default(cuid())
  teamId    String
  quotaType QuotaType?
  limit     Int        @default(0)
  used      Int        @default(0)
  team      Team       @relation(fields: [teamId], references: [id], onDelete: Cascade)
  @@unique([teamId, quotaType])
}

model Storage {
  id            String    @id @default(cuid())
  teamId        String
  botId         String
  fileName      String
  fileUrl       String
  type          String
  size          String
  status        String
  taskId        String
  ingestionInfo Json?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  isDeleted     Boolean   @default(false)
  team          Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model Content {
  id            String    @id @default(cuid())
  teamId        String
  botId         String
  content       Json?
  type          String
  status        String
  taskId        String
  ingestionInfo Json?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  isDeleted     Boolean   @default(false)
  team          Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model CustomerBots {
  id           String    @id @default(cuid())
  teamId       String
  botName      String
  botAvatar    String
  systemPrompt String    @default("")
  settings     Json?
  active       Boolean   @default(false)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  isDeleted    Boolean   @default(false)
  deletedAt    DateTime?
  team         Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model CustomerChats {
  id                  String                @id @default(cuid())
  teamId              String
  botId               String
  chatId              String
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  isDeleted           Boolean               @default(false)
  deletedAt           DateTime?
  totalTokens         Int?
  CustomerChatDetails CustomerChatDetails[]
  team                Team                  @relation(fields: [teamId], references: [id], onDelete: Cascade)
  GeoLocation         GeoLocation[]
}

model CustomerChatDetails {
  id           String        @id @default(cuid())
  chatId       String
  message      String
  sender       String
  tokenDetails Json?
  createdAt    DateTime      @default(now())
  chat         CustomerChats @relation(fields: [chatId], references: [id], onDelete: Cascade)
}

model GeoLocation {
  id                String        @id @default(cuid())
  chatId            String
  ip                String
  country           String
  countryCode       String
  region            String
  city              String
  timezone          String
  organization      String
  organization_name String
  latitude          Float
  longitude         Float
  accuracy          Int
  createdAt         DateTime      @default(now())
  chat              CustomerChats @relation(fields: [chatId], references: [id], onDelete: Cascade)
}

model fastapi_ingestiontask {
  task_id       String   @id @db.VarChar
  customer_cuid String   @db.VarChar
  bot_cuid      String   @db.VarChar
  status        String   @db.VarChar
  error_message String?  @db.VarChar
  created_at    DateTime @db.Timestamp(6)
  updated_at    DateTime @db.Timestamp(6)

  @@index([bot_cuid], map: "ix_fastapi_ingestiontask_bot_cuid")
  @@index([customer_cuid], map: "ix_fastapi_ingestiontask_customer_cuid")
}

enum QuotaType {
  BOT
  FILE
  TOKEN
}

enum SubscriptionTier {
  FREE
  PREMIUM
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  PAST_DUE
  CANCELED
  TRIALING
}

enum InvoiceStatus {
  DRAFT
  OPEN
  PAID
  VOID
  UNCOLLECTIBLE
}

enum FeedbackCategory {
  BUG_REPORT
  FEATURE_REQUEST
  GENERAL_FEEDBACK
}

enum FeedbackStatus {
  PENDING
  IN_REVIEW
  RESOLVED
}

model Subscription {
  id                        String             @id @default(cuid())
  userId                    String             @unique
  tier                      SubscriptionTier   @default(FREE)
  status                    SubscriptionStatus @default(INACTIVE)
  stripeCustomerId          String?            @unique
  stripeSubscriptionId      String?            @unique
  stripePriceId             String?
  currentPeriodStart        DateTime?
  currentPeriodEnd          DateTime?
  cancelAtPeriodEnd         Boolean            @default(false)
  monthlyTokenAllocation    Int                @default(0)
  tokensUsedThisMonth       Int                @default(0)
  additionalTokensPurchased Int                @default(0)
  spendingLimit             Float?
  createdAt                 DateTime           @default(now())
  updatedAt                 DateTime           @updatedAt
  user                      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoices                  Invoice[]
  tokenUsageLogs            TokenUsageLog[]
}

model BillingInfo {
  id                      String   @id @default(cuid())
  userId                  String   @unique
  firstName               String
  lastName                String
  email                   String
  address                 String
  country                 String
  stateRegion             String
  city                    String
  zipPostalCode           String
  isCompany               Boolean  @default(false)
  vatIdentificationNumber String?
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Invoice {
  id                   String        @id @default(cuid())
  subscriptionId       String
  stripeInvoiceId      String?       @unique
  amount               Float
  currency             String        @default("usd")
  status               InvoiceStatus @default(DRAFT)
  tokensCharged        Int           @default(0)
  billingPeriodStart   DateTime
  billingPeriodEnd     DateTime
  dueDate              DateTime?
  paidAt               DateTime?
  attemptedAt          DateTime?
  failureReason        String?
  reminderSentAt       DateTime?
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  subscription         Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
}

model TokenUsageLog {
  id             String       @id @default(cuid())
  subscriptionId String
  teamId         String?
  botId          String?
  chatId         String?
  tokensUsed     Int
  cost           Float
  createdAt      DateTime     @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
}

model SystemSettings {
  id                         String   @id @default(cuid())
  key                        String   @unique
  value                      String
  description                String?
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt
}

model Feedback {
  id        String           @id @default(cuid())
  userId    String
  userName  String
  userEmail String
  category  FeedbackCategory
  message   String
  status    FeedbackStatus   @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
}